/**
 * ADO Naturale - Azure OpenAI Client
 * Handles AI-powered natural language to ADO query conversion
 */

(function() {
  'use strict';
  
  /**
   * Azure OpenAI Client class
   */
  class OpenAIClient {
    constructor() {
      // These would typically come from environment variables or configuration
      // For now, we'll use placeholder values that need to be configured
      this.endpoint = null; // Will be set via configuration
      this.apiKey = null;   // Will be set via configuration
      this.deploymentName = 'gpt-4'; // Default deployment name
      this.apiVersion = '2024-02-15-preview';
      this.maxTokens = 1000;
      this.temperature = 0.1; // Low temperature for consistent, precise responses
    }
    
    /**
     * Configure the OpenAI client with credentials
     */
    configure(config) {
      this.endpoint = config.endpoint;
      this.apiKey = config.apiKey;
      this.deploymentName = config.deploymentName || this.deploymentName;
      this.apiVersion = config.apiVersion || this.apiVersion;
    }
    
    /**
     * Check if the client is properly configured
     */
    isConfigured() {
      return !!(this.endpoint && this.apiKey);
    }
    
    /**
     * Generate ADO query URL from natural language using Azure OpenAI
     */
    async generateQueryUrl(userInput, metadata, context = {}) {
      console.log('OpenAI Client: Starting query generation for:', userInput);
      console.log('OpenAI Client: Configuration check - configured:', this.isConfigured());
      
      if (!this.isConfigured()) {
        console.warn('OpenAI Client: Not configured, falling back to pattern matching');
        return this.fallbackToPatternMatching(userInput, metadata, context);
      }
      
      try {
        console.log('OpenAI Client: Building prompt...');
        const prompt = this.buildPrompt(userInput, metadata, context);
        console.log('OpenAI Client: Prompt built, calling OpenAI API...');
        
        const response = await this.callOpenAI(prompt);
        console.log('OpenAI Client: Received response from OpenAI:', {
          hasResponse: !!response,
          responseType: typeof response
        });
        
        // Extract and validate the URL from the response
        const queryUrl = this.extractQueryUrl(response);
        console.log('OpenAI Client: Extracted URL:', queryUrl ? 'URL found' : 'No URL found');
        
        if (this.validateQueryUrl(queryUrl, context)) {
          console.log('OpenAI Client: URL validation successful');
          return {
            success: true,
            url: queryUrl,
            confidence: 0.9,
            method: 'azure-openai',
            reasoning: response.reasoning || 'Generated by Azure OpenAI'
          };
        } else {
          console.warn('OpenAI Client: URL validation failed');
          throw new Error('Generated URL failed validation');
        }
        
      } catch (error) {
        console.error('OpenAI Client: Error during query generation:', error);
        console.log('OpenAI Client: Falling back to pattern matching');
        return this.fallbackToPatternMatching(userInput, metadata, context);
      }
    }
    
    /**
     * Build the prompt for Azure OpenAI
     */
    buildPrompt(userInput, metadata, context) {
      const systemPrompt = `You are an expert Azure DevOps Work Item Query Language (WIQL) generator.
Your task is to convert natural language queries into valid Azure DevOps query URLs.

IMPORTANT RULES:
1. Return ONLY a valid Azure DevOps query URL
2. Use the exact field names and values provided in the metadata
3. Ensure proper URL encoding
4. Use appropriate WIQL operators and syntax
5. Include proper SELECT, FROM, WHERE, and ORDER BY clauses

RESPONSE FORMAT:
Return a JSON object with:
{
  "url": "the complete Azure DevOps query URL",
  "reasoning": "brief explanation of the query logic"
}`;

      const metadataPrompt = this.buildMetadataPrompt(metadata);
      const contextPrompt = this.buildContextPrompt(context);
      const examplesPrompt = this.buildExamplesPrompt(metadata);
      
      const userPrompt = `User Query: "${userInput}"

Generate the appropriate Azure DevOps query URL for this request.`;

      return {
        system: systemPrompt,
        metadata: metadataPrompt,
        context: contextPrompt,
        examples: examplesPrompt,
        user: userPrompt
      };
    }
    
    /**
     * Build metadata section of the prompt
     */
    buildMetadataPrompt(metadata) {
      const workItemTypesInfo = Object.entries(metadata.workItemTypes)
        .map(([name, type]) => {
          const fields = Object.entries(type.fields)
            .filter(([_, field]) => field.isQueryable !== false)
            .map(([ref, field]) => {
              let fieldInfo = `  - ${field.name} (${ref}): ${field.type}`;
              if (field.allowedValues && field.allowedValues.length > 0) {
                fieldInfo += ` [${field.allowedValues.slice(0, 5).join(', ')}${field.allowedValues.length > 5 ? '...' : ''}]`;
              }
              return fieldInfo;
            })
            .slice(0, 10) // Limit fields to prevent prompt overflow
            .join('\n');
          
          return `${name}:\n${fields}`;
        })
        .join('\n\n');

      const commonFields = Object.entries(metadata.commonFields)
        .map(([natural, technical]) => `  "${natural}" â†’ ${technical}`)
        .join('\n');

      const teamMembers = metadata.teamMembers
        .slice(0, 10) // Limit to prevent prompt overflow
        .map(member => `  - ${member.displayName} (${member.uniqueName})`)
        .join('\n');

      const iterations = metadata.iterations
        .slice(0, 5) // Limit to prevent prompt overflow
        .map(iteration => `  - ${iteration.name} (${iteration.path})`)
        .join('\n');

      return `METADATA:

Organization: ${metadata.organization}
Project: ${metadata.project}

Work Item Types and Fields:
${workItemTypesInfo}

Common Field Mappings:
${commonFields}

Team Members:
${teamMembers}

Iterations/Sprints:
${iterations}

Query Operators:
  Equality: =, <>, !=
  Comparison: >, <, >=, <=
  Text: CONTAINS, CONTAINS WORDS, DOES NOT CONTAIN
  Special Values: @Me, @Today, @CurrentIteration, @StartOfWeek, @StartOfMonth`;
    }
    
    /**
     * Build context section of the prompt
     */
    buildContextPrompt(context) {
      let baseUrl;
      if (context.organization && context.project) {
        if (context.url?.includes('dev.azure.com')) {
          baseUrl = `https://dev.azure.com/${context.organization}/${context.project}`;
        } else if (context.url?.includes('.visualstudio.com')) {
          baseUrl = `https://${context.organization}.visualstudio.com/${context.project}`;
        } else {
          baseUrl = 'https://dev.azure.com/{org}/{project}';
        }
      } else {
        baseUrl = 'https://dev.azure.com/{org}/{project}';
      }

      return `CONTEXT:

Base URL: ${baseUrl}/_queries/query/
Current User: ${context.currentUser || '@Me'}
Current Date: ${new Date().toISOString().split('T')[0]}
URL Format: {baseUrl}/_queries/query/?wiql={encoded_wiql_query}`;
    }
    
    /**
     * Build examples section of the prompt
     */
    buildExamplesPrompt(metadata) {
      let baseUrl;
      if (metadata.organization && metadata.project) {
        // Determine hosting environment from the current URL or context
        const currentUrl = window.location.href;
        if (currentUrl.includes('dev.azure.com')) {
          baseUrl = `https://dev.azure.com/${metadata.organization}/${metadata.project}`;
        } else if (currentUrl.includes('.visualstudio.com')) {
          baseUrl = `https://${metadata.organization}.visualstudio.com/${metadata.project}`;
        } else {
          baseUrl = `https://dev.azure.com/${metadata.organization}/${metadata.project}`;
        }
      } else {
        baseUrl = 'https://dev.azure.com/{org}/{project}';
      }

      return `EXAMPLES:

Query: "Show me my bugs"
URL: ${baseUrl}/_queries/query/?wiql=SELECT%20%5BSystem.Id%5D%2C%20%5BSystem.Title%5D%2C%20%5BSystem.State%5D%2C%20%5BSystem.AssignedTo%5D%20FROM%20WorkItems%20WHERE%20%5BSystem.WorkItemType%5D%20%3D%20%27Bug%27%20AND%20%5BSystem.AssignedTo%5D%20%3D%20%40Me%20ORDER%20BY%20%5BSystem.CreatedDate%5D%20DESC

Query: "High priority user stories"
URL: ${baseUrl}/_queries/query/?wiql=SELECT%20%5BSystem.Id%5D%2C%20%5BSystem.Title%5D%2C%20%5BSystem.State%5D%2C%20%5BMicrosoft.VSTS.Common.Priority%5D%20FROM%20WorkItems%20WHERE%20%5BSystem.WorkItemType%5D%20%3D%20%27User%20Story%27%20AND%20%5BMicrosoft.VSTS.Common.Priority%5D%20%3C%3D%202%20ORDER%20BY%20%5BMicrosoft.VSTS.Common.Priority%5D

Query: "Items created this week"
URL: ${baseUrl}/_queries/query/?wiql=SELECT%20%5BSystem.Id%5D%2C%20%5BSystem.Title%5D%2C%20%5BSystem.WorkItemType%5D%2C%20%5BSystem.CreatedBy%5D%20FROM%20WorkItems%20WHERE%20%5BSystem.CreatedDate%5D%20%3E%3D%20%40StartOfWeek%20ORDER%20BY%20%5BSystem.CreatedDate%5D%20DESC`;
    }
    
    /**
     * Call Azure OpenAI API
     */
    async callOpenAI(prompt) {
      const url = `${this.endpoint}/openai/deployments/${this.deploymentName}/chat/completions?api-version=${this.apiVersion}`;
      
      console.log('OpenAI Client: Making API call to:', url);
      console.log('OpenAI Client: Using deployment:', this.deploymentName);
      
      const messages = [
        { role: 'system', content: prompt.system },
        { role: 'user', content: `${prompt.metadata}\n\n${prompt.context}\n\n${prompt.examples}\n\n${prompt.user}` }
      ];
      
      const requestBody = {
        messages,
        max_tokens: this.maxTokens,
        temperature: this.temperature,
        response_format: { type: 'json_object' }
      };
      
      console.log('OpenAI Client: Request body prepared, making fetch request...');
      
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'api-key': this.apiKey
        },
        body: JSON.stringify(requestBody)
      });
      
      console.log('OpenAI Client: Received HTTP response:', {
        status: response.status,
        statusText: response.statusText,
        ok: response.ok
      });
      
      if (!response.ok) {
        const errorText = await response.text();
        console.error('OpenAI Client: API error response:', errorText);
        throw new Error(`Azure OpenAI API error: ${response.status} ${response.statusText} - ${errorText}`);
      }
      
      const data = await response.json();
      console.log('OpenAI Client: Parsed JSON response:', {
        hasChoices: !!(data.choices && data.choices.length > 0),
        choicesCount: data.choices ? data.choices.length : 0
      });
      
      if (!data.choices || data.choices.length === 0) {
        console.error('OpenAI Client: No choices in response');
        throw new Error('No response from Azure OpenAI');
      }
      
      const content = data.choices[0].message.content;
      console.log('OpenAI Client: Extracted content from response, length:', content ? content.length : 0);
      
      try {
        const parsedContent = JSON.parse(content);
        console.log('OpenAI Client: Successfully parsed JSON response');
        return parsedContent;
      } catch (error) {
        console.warn('OpenAI Client: Failed to parse JSON, trying URL extraction');
        // If JSON parsing fails, try to extract URL from text
        const urlMatch = content.match(/https?:\/\/[^\s]+/);
        if (urlMatch) {
          console.log('OpenAI Client: Extracted URL from text response');
          return {
            url: urlMatch[0],
            reasoning: 'Extracted URL from text response'
          };
        }
        console.error('OpenAI Client: Could not parse response or extract URL');
        throw new Error('Could not parse OpenAI response');
      }
    }
    
    /**
     * Extract query URL from OpenAI response
     */
    extractQueryUrl(response) {
      if (typeof response === 'string') {
        // Try to extract URL from string response
        const urlMatch = response.match(/https?:\/\/[^\s]+/);
        return urlMatch ? urlMatch[0] : null;
      }
      
      if (response.url) {
        return response.url;
      }
      
      // Look for URL in various possible fields
      const possibleFields = ['query_url', 'queryUrl', 'adoUrl', 'result'];
      for (const field of possibleFields) {
        if (response[field] && typeof response[field] === 'string') {
          return response[field];
        }
      }
      
      return null;
    }
    
    /**
     * Validate the generated query URL
     */
    validateQueryUrl(url, context) {
      if (!url || typeof url !== 'string') {
        return false;
      }
      
      // Check if it's a valid URL
      try {
        new URL(url);
      } catch {
        return false;
      }
      
      // Check if it contains the expected ADO patterns
      const adoPatterns = [
        /dev\.azure\.com/,
        /\.visualstudio\.com/,
        /_queries\/query/,
        /wiql=/
      ];
      
      return adoPatterns.some(pattern => pattern.test(url));
    }
    
    /**
     * Fallback to pattern matching when OpenAI is not available
     */
    async fallbackToPatternMatching(userInput, metadata, context) {
      console.log('Using pattern matching fallback for query:', userInput);
      
      // Use the existing natural language processor as fallback
      if (window.ADONaturale_NLProcessor) {
        const processor = new window.ADONaturale_NLProcessor();
        const processedQuery = processor.processQuery(userInput, context);
        
        // Use the existing URL generator
        if (window.ADONaturale_URLGenerator) {
          const urlGenerator = new window.ADONaturale_URLGenerator();
          const url = urlGenerator.generateQueryURL(processedQuery, context);
          
          return {
            success: true,
            url,
            confidence: processedQuery.confidence || 0.7,
            method: 'pattern-matching',
            reasoning: 'Generated using pattern matching fallback'
          };
        }
      }
      
      // Ultimate fallback - basic URL construction
      const baseUrl = context.organization && context.project
        ? (context.url?.includes('dev.azure.com')
          ? `https://dev.azure.com/${context.organization}/${context.project}`
          : `https://${context.organization}.visualstudio.com/${context.project}`)
        : 'https://dev.azure.com/org/project';
      
      const basicWiql = `SELECT [System.Id], [System.Title], [System.WorkItemType], [System.State] FROM WorkItems WHERE [System.Title] CONTAINS '${userInput.replace(/'/g, "''")}'`;
      const encodedWiql = encodeURIComponent(basicWiql);
      
      return {
        success: true,
        url: `${baseUrl}/_queries/query/?wiql=${encodedWiql}`,
        confidence: 0.3,
        method: 'basic-fallback',
        reasoning: 'Basic text search fallback'
      };
    }
    
    /**
     * Get configuration from storage or environment
     */
    async loadConfiguration() {
      try {
        // Try to get configuration from extension storage
        const config = await new Promise((resolve) => {
          chrome.runtime.sendMessage(
            { action: 'getOpenAIConfig' },
            (response) => {
              if (chrome.runtime.lastError) {
                resolve(null);
              } else {
                resolve(response);
              }
            }
          );
        });
        
        if (config) {
          this.configure(config);
          return true;
        }
        
        return false;
      } catch (error) {
        console.warn('Could not load OpenAI configuration:', error);
        return false;
      }
    }
    
    /**
     * Test the OpenAI connection
     */
    async testConnection() {
      if (!this.isConfigured()) {
        return { success: false, error: 'Not configured' };
      }
      
      try {
        const testPrompt = {
          system: 'You are a test assistant. Respond with a simple JSON object.',
          user: 'Return {"test": "success", "message": "Connection working"}'
        };
        
        const response = await this.callOpenAI(testPrompt);
        
        return {
          success: true,
          response: response
        };
      } catch (error) {
        return {
          success: false,
          error: error.message
        };
      }
    }
  }
  
  // Make the class globally available
  window.ADONaturale_OpenAIClient = OpenAIClient;
  
})(); 